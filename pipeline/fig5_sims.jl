
# ----------------------------------------------------------------------------------------------------------------
# get raw data as template 
data = CSV.read("./../output/data_processed.csv",DataFrames.DataFrame);

# get GP output for fitting 
pred_dir = "./../output" 
data_gp = CSV.read(pred_dir*"/gp/data/preds.csv",DataFrame);
data = data[data.length .>=9,:]
lineages = unique(data.lineage);

# ----------------------------------------------------------------------------------------------------------------
# setup 
# Create τ_range as an array of floats
τ_range = [5.4]
Td = 8.7 # generation time 


# get fitted params generated by fitting.jl
d_fits = CSV.read("./../output/fitted_params.csv",DataFrame)
d_fits[:,:t_OU] = 1 ./d_fits[:,:γ_OU]; 
d_fits[:,:t_DN] = 1 ./d_fits[:,:γ_DN];

# get a value for the overall growth rate variance
df_gp = data_gp[data_gp.lineage .== lineages[3], :]
positions = unique(df_gp.position)
σλbar2 = var([mean(df_gp[df_gp.position .== p,:].matern32_flucs_x) for p in positions])

# generate values from σλbar2*10^(-7) to σλbar for the contribution of cont. flucs to the overall variance
# don't start exactly at 0 to avoid zero variance. 
σc2_range = collect(LinRange(10^(-7)*σλbar2, σλbar2, 15))

# ----------------------------------------------------------------------------------------------------------------
# 
nreps = 20
sims = []
global k = 1
for lin in lineages
    println(" * replicating lineage "*string(lin)*"--------------")

    # Get the lineage to replicate
    df_gp = data_gp[data_gp.lineage .== lin, :]
    df = data[data.lineage .== lin, :]

    # Get the parameters for this lineage
    Δ = d_fits[d_fits.lineage .== lin, :Δ][1]
    λ0 = d_fits[d_fits.lineage .== lin, :λ0][1]
    σM = d_fits[d_fits.lineage .== lin, :σM][1]

    for s2 in σc2_range
        for τ in τ_range
            println("-----------------------------------------------------")
            # s^2 = 2*D/(g^2Td)
            # σλbar2 = s^2 + (τ^2/Td^2)*σDN^2 (equations 11,12,13 in paper)
            # solve for D
            #D = s .^2/2*Td/τ^2
            #σDN = τ/Td*sqrt(σλbar2 - s.^2) # this called σz in the paper -- sorry!
            D,σDN = GrowthTraceTools.solve_D_σz_from_s2_and_varbar(1/τ, Td, s2, σλbar2)
            println("τ = "*string(τ)*", D = "*string(D))
            
            # Setup parameters
            θ = (
                Δ = Δ,
                σDN =σDN,
                τ = τ,
                D = D,
                λ0 = λ0,
                σM = σM
            )

            for i in ProgressBar(1:nreps)
                println("    θ = ", θ)
                init = [θ.Δ, θ.λ0 + rand(Normal(0, sqrt(D * τ))), 2 * θ.Δ]
                dt = df.time[2] - df.time[1]
                sim = GrowthTraceTools.simulate_ou(θ, init,collect(0:0.1:maximum(df.time)) )
                sim = sim[sim.position .< max(sim.position...), :]
                sim[:, :lineage_original] .= lin
                sim[:, :replicate] .= i
                sim[:, :lineage] .= k
                sim[:, :τ] .= θ.τ
                sim[:, :D] .= θ.D
                sim[:, :σDN] .= θ.σDN
                sim[:, :σ2c] .= s2

                push!(sims, sim)
                global k += 1
            end
        end
    end
end
sims = vcat(sims...);

CSV.write("./../output/fig5_sims.csv",sims)



