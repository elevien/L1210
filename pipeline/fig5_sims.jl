
# ----------------------------------------------------------------------------------------------------------------
# get raw data as template 
data = CSV.read("./../output/data_processed.csv",DataFrames.DataFrame);

# get GP output for fitting 
pred_dir = "./../output/" # CHECK 
data_gp = CSV.read(pred_dir*"/data_gp_preds.csv",DataFrame);
data = data[data.length .>=9,:]
lineages = unique(data.lineage);

# ----------------------------------------------------------------------------------------------------------------
# setup 
# Create τ_range as an array of floats
τ_range = collect(1.0:0.2:6.0)
Td = 13. # generation time 
D_range = collect(range(6.4e-6, 6.4e-9, length=8))

# get fitted params generated by fitting.jl
d_fits = CSV.read("./../output/fitted_params.csv",DataFrame)
d_fits[:,:t_OU] = 1 ./d_fits[:,:γ_OU]; 
d_fits[:,:t_DN] = 1 ./d_fits[:,:γ_DN];

# ----------------------------------------------------------------------------------------------------------------
# 
nreps = 10
sims = []
global k = 1
for τ in τ_range
    for D in D_range

        println("-----------------------------------------------------")
        println("τ = "*string(τ))
        for lin in lineages
            println(" * replicating lineage "*string(lin)*"--------------")
            # -----------------------------------------------------------

            # get the lineage to replicate
            df_gp = data_gp[data_gp.lineage .==lin,:]
            df = data[data.lineage .==lin,:]
            
            # get the parameters for this lineage
            Δ = d_fits[d_fits.lineage .==lin,:Δ][1]                 # average cell size
            λ0 = d_fits[d_fits.lineage .==lin,:λ0][1]               # average growth rate
            σM = d_fits[d_fits.lineage .==lin,:σM][1]               # division noise

            σλbar2 = D * τ^2/Td # this is the cell-cycle averaged growth rate variation of this lineage

            # we don't get v from fitting, instead it is determined by avr
            v = (2*σλbar2- 2*D *τ^2/Td)*(Td/τ)^2


            # σDN = sqrt(d_fits[d_fits.lineage .==lin,:v][1])        # division size variation
            # the cell-cycle averaged growth rate variation for this lineage based on fitting
            # this is fixed for all lineages (generation time is approximate and not important for results)

            # setup params
            θ = (Δ = Δ, 
                σDN=sqrt(v),
                τ = τ,
                D=D,
                λ0 = λ0, 
                σM = σM)
            
          
            for i in ProgressBar(1:nreps)

                # -----------------------------------------------------------
                # build OU model and run (all noise in diffusion coefficient)
                println("    θ = ",θ)
                init = [θ.Δ,θ.λ0,2*θ.Δ] # size, growth rate, division size
            

                # run
                init = [θ.Δ,θ.λ0 + rand(Normal(0,sqrt(D * τ))),2*θ.Δ]
                prob,callback,names = GrowthTraceTools.build_model_OU(θ,init,df.time)
                sol = solve(prob,EM(),callback = callback);
        

            
                # put in dataframe 
                sim = GrowthTraceTools.solver_output_to_dataframe(sol,[:M,:λ,:Mf])
                sim = sim[sim.position .< max(sim.position...),:]
                sim[:,:lineage_original] = ones(length(sim.time)) .* lin
                sim[:,:replicate] = ones(length(sim.time)) .* i
                sim[:,:lineage] = ones(length(sim.time)) .* k
                sim[:,:τ] = ones(length(sim.time)) .* τ
                sim[:,:D] = ones(length(sim.time)) .* θ.D
                sim[:,:σDN] = ones(length(sim.time)) .* θ.σDN
                push!(sims,sim)

                global k = k+1
            end
        end
    end
end
sims = vcat(sims...);

CSV.write("./../output/fig5_sims.csv",sims)



# IGNORE
    # sol = [init]
            # for t in 2:length(df.time)
            #     M,λ,Mf = sol[end]
            #     dt = (df.time[t] - df.time[t-1])
            #     Mnew = M + λ*M * dt
            #     λnew = λ + 1/θ.τ * (θ.λ0 - λ) * dt + sqrt(dt)*rand(Normal(0,θ.D))
            #     if Mnew >= Mf
            #         Mnew = Mnew/2
            #         λnew = λnew + rand(Normal(0,θ.σDN))
            #         Mfnew = Mnew + rand(Normal(θ.Δ,θ.σM))
            #     else
            #         Mfnew = Mf
            #     end
            #     push!(sol,[Mnew,λnew,Mfnew])
            # end
            # sol = hcat(sol...)