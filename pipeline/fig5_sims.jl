
# ----------------------------------------------------------------------------------------------------------------
# get raw data as template 
data = CSV.read("./../output/data_processed.csv",DataFrames.DataFrame);

# get GP output for fitting 
pred_dir = "./../output/gp/data" # CHECK 
data_gp = CSV.read(pred_dir*"/preds.csv",DataFrame);
data = data[data.length .>=9,:]
lineages = unique(data.lineage);

# ----------------------------------------------------------------------------------------------------------------
# setup 
# Create τ_range as an array of floats
τ_range = Float64.(1:5)
#ϕ_range = collect(range(1e-4, 1.0 - 1e-4, length=5))
D_range = collect(range(6.4e-6, 6.4e-9, length=5))

# get fitted params generated by fitting.jl
d_fits = CSV.read("./../output/fitted_params.csv",DataFrame)
d_fits[:,:t_OU] = 1 ./d_fits[:,:γ_OU];
d_fits[:,:t_DN] = 1 ./d_fits[:,:γ_DN];

# ----------------------------------------------------------------------------------------------------------------
# 
nreps = 5
sims = []
global k = 1
for τ in τ_range
    for D in D_range

        println("-----------------------------------------------------")
        println("τ = "*string(τ))
        for lin in lineages
            println(" * replicating lineage "*string(lin)*"--------------")
            # -----------------------------------------------------------
            df_gp = data_gp[data_gp.lineage .==lin,:]
            df = data[data.lineage .==lin,:]

            # get params for this lineage and $\phi$ and $\tau$
            # 
            #D = d_fits[d_fits.lineage .==lin,:D][1]
            τOU = τ
            τDN = τ
            Δ = d_fits[d_fits.lineage .==lin,:Δ][1]
            λ0 = d_fits[d_fits.lineage .==lin,:λ0][1]
            σM = d_fits[d_fits.lineage .==lin,:σM][1]
            σDN = sqrt(d_fits[d_fits.lineage .==lin,:σ2][1])

            # the cell-cycle averaged growth rate variation for this lineage based on fitting
            # we want this to be fixed
            σλbar2 = D * τOU^2/13.0



          
            for i in ProgressBar(1:nreps)

                # -----------------------------------------------------------
                # build OU model and run (all noise in diffusion coefficient)

                # setup params
                θ = (Δ = Δ, σDN=0,τ = τOU,D=D ,λ0 = λ0, σM = σM)
                # 
                θ = @set θ.σDN = sqrt(2*σλbar2- 2*D *τ^2/13.0)*(13.0/τ)

                # OLD VERSION DETERMINED D and sigmaDN from phi
                #θ = @set θ.D =σλbar2 *13.0/θ.τ^2 * ϕ^2 /2
                #θ = @set θ.σDN =  sqrt(σλbar2 .* 13.0/θ.τ)  .* sqrt((1-ϕ^2))
                # Determine sigmaDN based on D
                println("    θ = ",θ)
                init = [θ.Δ,θ.λ0,2*θ.Δ] # size, growth rate, division size
            

                # run
                init = [θ.Δ,θ.λ0 + rand(Normal(0,GrowthTraceTools.σGR)),2*θ.Δ]
                prob,callback,names = GrowthTraceTools.build_model_OU(θ,init,df.time)
                sol = solve(prob,EM(),callback = callback);
                # sol = [init]
                # for t in 2:length(df.time)
                #     M,λ,Mf = sol[end]
                #     dt = (df.time[t] - df.time[t-1])
                #     Mnew = M + λ*M * dt
                #     λnew = λ + 1/θ.τ * (θ.λ0 - λ) * dt + sqrt(dt)*rand(Normal(0,θ.D))
                #     if Mnew >= Mf
                #         Mnew = Mnew/2
                #         λnew = λnew + rand(Normal(0,θ.σDN))
                #         Mfnew = Mnew + rand(Normal(θ.Δ,θ.σM))
                #     else
                #         Mfnew = Mf
                #     end
                #     push!(sol,[Mnew,λnew,Mfnew])
                # end
                # sol = hcat(sol...)

            
                # put in dataframe 
                sim = GrowthTraceTools.solver_output_to_dataframe(sol,[:M,:λ,:Mf])
                sim = sim[sim.position .< max(sim.position...),:]
                sim[:,:lineage_original] = ones(length(sim.time)) .* lin
                sim[:,:replicate] = ones(length(sim.time)) .* i
                sim[:,:lineage] = ones(length(sim.time)) .* k
                sim[:,:ϕ] = ones(length(sim.time)) .* ϕ
                sim[:,:τ] = ones(length(sim.time)) .* τ
                sim[:,:D] = ones(length(sim.time)) .* θ.D
                sim[:,:σDN] = ones(length(sim.time)) .* θ.σDN
                push!(sims,sim)

                global k = k+1
            end
        end
    end
end
sims = vcat(sims...);

CSV.write("./../output/sims_models.csv",sims)